---
title: Fabric MQ
in_menu: false
sort_info: 10
---
{:toc}

## MQ Profiles

In Fabric, everything is defined through profiles. The main profile for ActiveMQ brokers is called **mq-base** and it defines basic options for the broker instances.
It's an abstract profile, so you shouldn't ever try to create a child instance using this profile, as it will not give you the expected effect.
For basic broker creation you can use **mq** profile which inherits most of its properties from **mq-base**.

## Creating new broker instances

For creating new brokers in Fabric environment, you should use **mq-create** command. However, you can use general-purpose **mq** profile to to create a simple broker instances like

    FuseFabric:karaf@root> container-create-child --profile mq root broker1
    The following containers have been created successfully:
	    broker1

This will create a new container called **broker1** and with broker (of the same name) running on it.

You can achieve the same with the following

    FuseFabric:karaf@root> mq-create --create-container broker1 broker1
    MQ profile broker1 ready
    Successfully created container broker1

Just like the basic **container-create-child** command this one will create container called **broker1** and run a broker on it.
One difference is that it will not use **mq** profile, but it will create a new one (called **broker1**) which will of course inherit most of the stuff from **mq-base** profile.


## Starting broker on existing instances

The first thing where **mq-create** command show its power is that you can use it to start brokers on existing containers. Let's take a look at the following example

    FuseFabric:karaf@root> container-create-child --profile karaf  root broker1
    The following containers have been created successfully:
	    broker1

    FuseFabric:karaf@root> mq-create --assign-container broker1 broker1
    MQ profile broker1 ready
    Profile successfully assigned to broker1


Here, we first create an "empty" child container and later started **broker1** on it with **assign-container** option.
Of course, instead of local child container we can assign broker to ssh and cloud containers.

## Connecting to the broker

So far we discussed how we can start brokers in Fabric environment. Now let's discuss for a bit how Fabric discovery works and how clients can connect to the broker.
Every broker started in fabric has its group. If nothing is specified it's **default**.
This means that when the broker starts, it will register itself to the fabric registry under the defined group.
All the client needs to do then is to use connection url like

    discovery:(fabric:default)

where default in this case is the group name we want use. The connection factory will then find available brokers in the group and connect the client to the one of them.
You can test the brokers started with the previously described methods by creating a container with **example-mq** profile

    container-create-child --profile example-mq  root example

After the container is successfully provisioned, you check its logs and verify the flow of messages.

## Topologies

### Clusters

So far, we've seen how to start and connect to one broker. The basic "cluster" of brokers means that you can start multiple brokers in the same group.
Those are all by default non-connected brokers, so clients will naturally load balanced across them.
This type of setup could be ideal for load balancing non-persistent messages and provide high-availability for that case.

### Master-Slave

Master-Slave topologies are also very easy to set. All you need to do is to start multiple brokers with same name (in the same group) and Fabric registry will do the rest for you.
So if you do something like

    mq-create --create-container broker1,broker2,broker3 hq-broker

it will create two container instances (broker1, broker2 and broker3) and try to start broker named **hq-broker** in the group **default** on all of them.
The first broker that starts will become the master, while the others will be the slave.
You can run the same example as before and test what happens when you stop the master (one of the slaves should take over and client should reconnect).
If brokers are persistent you need to ensure that all use the same store, which is the case by default on child instances.
When running instances on separate machines and using shared storage it will require some additional setup. We'll cover further customization later on.

The benefit of this kind of master-slave setup is that you don't depend on locking strategies of shared storage (and can even use it with non-persistent brokers).
Also the clients can use Fabric discovery mechanism to connect to brokers.

One more feature of Fabric Master-Slave setups is that you can share same containers between multiple master-slave tuples.
Take for example the scenario that aside **hq-broker** described above you need another one in the same data center. You can do the following

    mq-create --assign-container broker1,broker2,broker3 web-broker

This will assign new web-broker profile to the same instances already running hq-broker.
The internal Fabric mechanism will prevent two masters to run on the same instance, so the master will be elected by one of the two instances running the slave for the **hq-broker**.
The other brokers will run slaves for the **web-broker**. In this scenario we have two masters running and two slaves waiting. This is just a simple example, but it shows how it can help better utilize the resources.

### Networks

If you want your broker to establish network connections to other brokers from a specific group, you can specify it with the **networks** option to the **mq-create** command. Examine the following scenario

    mq-create --group us-east --networks us-west --create-container us-east1,us-east2 us-east

We created a **us-east** broker (master-slave pair) in the **us-east** group on two container instances in a data center.
We also defined we want to network this broker with the broker in **us-west** group. Let's now create that brokers

    mq-create --group us-west --networks us-east --create-container us-west1,us-west2 us-west

Now we have two master-slave pair of brokers mutually networked. There's also an example profile that demo this topology. You can run

    container-create-child --profile example-mq-cluster  root example

and see a producer sending messages to east coast cluster, using

    discovery:(fabric:us-east)

url and consumer consuming messages from west coast cluster using

    discovery:(fabric:us-west)

url

## Customizations

So far we've seen how to run and connect to the brokers in Fabric environment. But we never discussed where there configuration is and how we can customize
broker behavior. As with the standalone brokers, the most of the behavior is configured through XML configuration and tweaked using properties.
The difference, when you're setting up things in Fabric is that your XML configuration is stored in ZooKeeper registry and properties are kept in
appropriate configuration pids in broker's profile.

For starters let's see what can you do wit properties. If you take a look at the example of creating a networked broker with **mq-create** command, like

    mq-create --create-container broker1 --networks default broker1

You can expect new Fabric profile to be created (called **broker1**) and assigned to a newly created container of the same name.
To understand better how broker is configured, let's take a look at the profile

    FuseFabric:karaf@root> profile-display broker1
    Profile id: broker1
    Version   : 1.0
    Parents   : mq-base
    Associated Containers :

    Container settings
    ----------------------------

    Configuration details
    ----------------------------
    PID: org.fusesource.mq.fabric.server-broker1
    standby.pool default
    connectors openwire
    broker-name broker1
    data /Users/dejanb/workspace/forge/fuseenterprise/fabric/fuse-fabric/target/fuse-fabric-7.0-SNAPSHOT/data/cache/bundle53/data/broker1
    config zk:/fabric/configs/versions/1.0/profiles/mq-base/broker.xml
    group default
    network default

You can see that under the configuration details we have a bunch of properties that defines broker behavior. Some of those, like **network** or **group**
we were explicitly setting using **mq-create** in previous example. you probably won't touch basic things once you created your broker profile but you can
add more properties there to further tune it.

### Networks

For example, one of the differences is how networks are created. As network connectors in this case uses Fabric discovery to find brokers it'll connect to,
they are configured using properties. You can additionally configure network connectors by setting properties prefixed with **network.**. For example

    profile-edit -p org.fusesource.mq.fabric.server-broker1/network.bridgeTempDestinations=false broker1


will add

    network.bridgeTempDestinations=false

to the properties making it reconfigure.

### Config

As you could see in the previous example, a default XML configuration template for the brokers is taken from the ZooKeeper path

   /fabric/configs/versions/1.0/profiles/mq-base/broker.xml

and it looks like

{pygmentize:: xml}
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:amq="http://activemq.apache.org/schema/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd">

    <!-- Allows us to use system properties and fabric as variables in this configuration file -->
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="properties">
            <bean class="org.fusesource.mq.fabric.ConfigurationProperties"/>
        </property>
    </bean>

    <broker xmlns="http://activemq.apache.org/schema/core" brokerName="${broker-name}" dataDirectory="${data}" start="false">

        <destinationPolicy>
            <policyMap>
              <policyEntries>
                <policyEntry topic=">" producerFlowControl="true" memoryLimit="1mb">
                  <pendingSubscriberPolicy>
                    <vmCursor />
                  </pendingSubscriberPolicy>
                </policyEntry>
                <policyEntry queue=">" producerFlowControl="true" memoryLimit="1mb">
                </policyEntry>
              </policyEntries>
            </policyMap>
        </destinationPolicy>

        <managementContext>
            <managementContext createConnector="false"/>
        </managementContext>

        <persistenceAdapter>
            <kahaDB directory="${data}/kahadb"/>
        </persistenceAdapter>

        <transportConnectors>
            <transportConnector name="openwire" uri="tcp://0.0.0.0:0"/>
        </transportConnectors>
    </broker>

</beans>
{pygmentize}

Note that some of the properties from the configuration are used in this template (like **broker-name** and **data**)
and it's important that you reuse them properly. You can edit this configuration with some of our tools like IDE or FMC
but also you might want to use the XML template from some other place. For that you can import the config in the ZooKeeper registry like

    zk:import -v -t /fabric/configs/versions/1.0/profiles/mq-base/mybroker.xml /workspace/export/mybroker.xml

Now you can create a broker with **data** argument specified and use this customized configuration template, like

    mq-create --config mybroker.xml broker1

Note that **config** option will assume that configuration is stored in the current version of **mq-base** profile.



TODO



### Data

TODO






